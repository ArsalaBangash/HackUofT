CSC 369- MidTerm Prep

Week 4: More synchronization and Scheduling

-Semaphores:
	- Abstract data types
	-Integer variable accessed only through 2 atomic operations
	-wait() (also called P or decrement) â€“ decrement the variable and block until semaphore is free
	- signal() (also called V or increment) increment the variable, unblock a waiting thread if there are any
	-keeps a queue of waiting threads
	-two types (Binary and Counting) depending on what the initial value is


-Binary Semaphore (Locks):
	-Functions like a lock
	e.g:
    sem_t m;
    sem_init(&m, 0, 1); //init to value 1
    sem_wait(&m); //lock
    do_work();//CS
    sem_post(&m)//unlock
  -sem_wait: decrement and wait until value is non-negative
  -sem_post: increment and wake up a waiting thread

  -Counting Semaphore:
    - A semaphore with initial value N > 1
    - Represents a resource with many units available, or a
    resource that allows certain kinds of unsynchronized concurrent access (e.g., reading)
    -Multiple threads can pass the semaphore
    -Max number of threads is determined by semaphore's inital value N
      - N = 1; mutex/lock (only one thread can pass the semaphore at a time)
  *Side note, atomic operation means an operation that appears to be instanteaneous from the presepective of all other
  -Difference between Lock and Semaphore:
    -A binary semaphore (with intial value 1) can be used a s a lock
    -Semantically different
      -Logically lock has owner
      -Semaphore doesnt have the concept of owner
      -Lock is easier for reasoning about synchronization
      than semaphore is

  The readers/writers problem:
    -An object is shared among severla threads
    -Some only read the object, others only write it
    -We can allow multiple concurrent readers
    -Only one writer
    -Use 3 variables:
      -Semaphore w_or_r- exclusive writing or reading
        -Think of it as a token that can be held either by the
        group of readers or by one individual writer.
        -Which thread in the group of readers is in charge of getting and returning the
        token? The Last thread
        -int readcount -number of threads reading object
          - Needed to detect when a reader is the first or last of a group
        -Semaphore mutex - control access to readcount

    Writer's operation:
      int readcount = 0;
      Semaphore mutex = 1;
      Semaphore w_or_r = 1;

      simple wait and signal calls so that the
      the wait locks out others and only one writer ca
      write only

      Signal then makes the w_or_r token up for grabs


    Readers Operation:
      wait(mutex); //lock readcount
      // one more reader
      readcount += 1;
      // is this the first reader?
      if(readcount == 1)
          //synch w/ writers
          wait(w_or_r);
      //unlock readcount
      signal(mutex);
      Read;
      wait(mutex); //lock readcount
      readcount -= 1;
      if(readcount == 0)
          signal(w_or_r);
      signal(mutex);


    -Issues with this solutions rise when there is a context swithc right after the
    first reader decrements the readcount, because the readcount is 0 and you are going to
    give the writer access to write but the purpose of the readcount then fails


    Notes on Readers/Writers
      -If there is a writer
        -First reader reader blocks on w_or_r
        -All other readers block on mutex
      -Once a writer exits, all readers can proceed
      -The last reader to exit signals a waiting writer
      -If readers and writers are waiting on w_or_r, and a writer exits,
      who goes first?
        -Depends on the scheduler


   Monitors:
      -An abstract data type with restriction that only one
      thread at a time can be active in the monitor
        -Local data accessed only by monitor's procedures
        -Process enters monitor by invoking 1 of its procedures
        -Other processes that attempt to enter monitor are blocked
      -Local data only accessed by procedures in the monitor
      -Different threads trying to enter the monitors cooperate with
      each other, i.e, they block and wake up each other


      Enforcing single access:
        -A process in the monitor may need to wait for something to happen
          -May need to let other process use the monitor
          -Provide a special type of variable called a condition
          -Wait(suspend the invoking process)
          -Signal (resume exactly one suspended process)
            -If no process is suspended, a signal has no effect

      More on Monitors:
        -If process P executes an x.signal operation and there exits
        a process Q waiting on condition x, we have a problem:
          -P is already  "in the monitor" does not need to block
          -Q becomes unblocked by the signal, and wants to resume
          execution in the monitor
          -But both cannot be simultaneously active in the monitor!


      The readers/writers problem with Monitors:
